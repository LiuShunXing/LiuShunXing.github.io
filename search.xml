<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>let 和 const 命令</title>
      <link href="posts/1e61.html"/>
      <url>posts/1e61.html</url>
      
        <content type="html"><![CDATA[<h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><hr><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><hr><p>声明变量只在这个作用域有效，不会影响作用域外的变量，外界也不能修改它。</p><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，造成很多不合理的场景。</p><p>一、内层变量可能会覆盖外层变量：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">var tmp = new Date();function f() &#123;  console.log(tmp);  if (false) &#123;    var tmp = 'hello world';  &#125;&#125;f(); // undefined //变量提升，导致内层的tmp变量覆盖了外层的tmp变量。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、用来计数的循环变量泄露为全局变量：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">var s = 'hello';for (var i = 0; i < s.length; i++) &#123;  console.log(s[i]);&#125;console.log(i); // 5  //变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何形成块级作用域？块级作用域有啥特点? 看 let 和 const 命令</p><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><hr><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是<strong>let声明的变量只在它所在的代码块有效</strong>。</p><p>在<code>for</code>循环中，就很合适使用let命令。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">for (let i = 0; i < 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not definedvar a = [];for (let i = 0; i < 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[6](); // 6//当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用let命令，在for循环还有一个特别之处，就是<strong>设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</strong>。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">for (let i = 0; i < 3; i++) &#123;  let i = 'abc';  console.log(i);&#125;// abc// abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><hr><p><code>const</code>声明一个<strong>只读的常量，一旦声明，常量的值就不能改变</strong>。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>const</code>声明的变量不得改变值，这意味着，<strong>const一旦声明变量，就必须立即初始化，不能留到以后赋值</strong>。</p><blockquote><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个<strong>内存地址</strong>所保存的数据不得改动。<br>主要针对引用类型（对象或数组）来说，只能保证指向整个对象的地址不变，而不能保证对象内部属性的地址指向也不改变。</p></blockquote><h2 id="let-和-const-命令的异同"><a href="#let-和-const-命令的异同" class="headerlink" title="let 和 const 命令的异同"></a>let 和 const 命令的异同</h2><hr><p>相同点：</p><ul><li><strong>不存在（变量）提升，存在暂时性死区，只能在声明的位置后面使用</strong>。</li><li><strong>只在声明所在的块级作用域内有效</strong>。</li><li><strong>在相同作用域内下不可重复申明</strong>。</li><li><strong>全局声明不属于顶层对象的属性（浏览器顶层对象是window，node顶层对象是global）</strong>。</li></ul><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><hr><p>举个例子吧：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">var tmp = 123;if (true) &#123;  tmp = 'abc'; // ReferenceError  let tmp;&#125;//存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结下：</p><blockquote><p>如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭(或者称为绑定)作用域。凡是在声明之前就使用这些变量，就会报错。</p></blockquote><p>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>（temporal dead zone，简称 TDZ）。</p><p>所以：在<code>let</code>命令声明变量tmp之前，都属于变量tmp的“死区”。</p><p>暂时性死区也意味着 <code>typeof</code> 不再是一个百分之百安全的操作。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">typeof x; // ReferenceErrorlet x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h2><hr><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><p>但是，但是，浏览器没有遵守这个规定。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">// 情况一if (true) &#123;  function f() &#123;&#125;&#125;// 情况二try &#123;  function f() &#123;&#125;&#125; catch(e) &#123;  // ...&#125;//为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，实际都能运行，不会报错。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用（<strong>但、但、但是，看下面分析</strong>）。</p><p>举个例子：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">function f() &#123; console.log('I am outside!'); &#125;(function () &#123;  if (false) &#123;    // 重复声明一次函数f    function f() &#123; console.log('I am inside!'); &#125;  &#125;  f();&#125;());//在 ES5 中运行，if内声明的函数f会被提升到函数头部，所以得到 I am inside!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ES6 就完全不一样了。<br>大胆猜一下，I am outside!（因为块级作用域内声明的函数类似于let，对作用域之外没有影响），浏览器一运行，报错！！！！</p><p>为啥报错！</p><p>为了解决浏览器实现上面规则出现的不兼容性，ES6 允许浏览器浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><p>所以在<strong>ES6 的浏览器</strong>中，这样处理：</p><blockquote><p>允许在块级作用域内声明函数。<br>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>同时，函数声明还会提升到所在的块级作用域的头部。</p></blockquote><p>上面的例子实际运行的代码如下：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123;  var f = undefined;  if (false) &#123;    function f() &#123; console.log('I am inside!'); &#125;  &#125;  f();&#125;());// Uncaught TypeError: f is not a function<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实际开发避免块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</strong></p><p>注意点：</p><ol><li>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。<pre class="line-numbers language-JavaScript"><code class="language-JavaScript">// 第一种写法，报错if (true) let x = 1;// 第二种写法，不报错if (true) &#123;let x = 1;&#125;// 不报错'use strict';if (true) &#123;function f() &#123;&#125;&#125;// 报错'use strict';if (true)function f() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2></li></ol><hr><p>前面说到：<code>let</code>、<code>const</code>命令全局声明不属于顶层对象的属性。</p><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p><p>浏览器顶层对象是<code>window</code>，node顶层对象是<code>global</code>。</p><p>ES2020，引入 <code>globalThis</code>作为顶层对象, 以在所有环境拿到 顶层对象<code>globalThis</code>。</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 块级作用域 </tag>
            
            <tag> let、const </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存（二）</title>
      <link href="posts/4e01.html"/>
      <url>posts/4e01.html</url>
      
        <content type="html"><![CDATA[<h1 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h1><hr><p>HTTP 缓存通常也叫浏览器缓存，是网站性能优化的重要方式。<br>HTTP 缓存主要针对页面的静态资源，一般对页面静态资源有两点要求：</p><ol><li>静态资源加载速度</li><li>页面渲染速度</li></ol><p>页面的渲染是建立在资源加载速度之上的，同时但不同资源类型的加载顺序和时机也会对其产生影响，所以 HTTP 缓存的可操作空间非常大。</p><p>缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）</p><p>浏览器缓存策略分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>。要根据响应的 <code>header</code>内容来决定。</p><h2 id="缓存相关-header"><a href="#缓存相关-header" class="headerlink" title="缓存相关 header"></a>缓存相关 header</h2><hr><ul><li><code>Cache-Control</code>： 请求/响应头，缓存控制字段，精确控制缓存策略。有以下常用值：<ul><li><code>no-store</code>：不缓存，每次从服务器请求完整的资源。</li><li><code>no-cache</code>：缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否过期，若未过期（返回304），则缓存才使用本地缓存副本。</li><li><code>max-age=x</code>：单位秒，请求缓存后的X秒不再发起请求(时间段)，http1.1属性，与<code>Expires</code>(http1.0属性)类似，但优先级要比Expires高。</li><li><code>s-maxage=x</code>：单位秒，代理服务器请求源站缓存后的X秒不再发起请求，只对<code>CDN</code>缓存有效。</li><li><code>public</code>：公共缓存，用于客户端和代理服务器(CDN)。</li><li><code>private</code>: 私有缓存,用于浏览器的个人用户。</li></ul></li><li><code>Expires</code>：响应头，代表该资源的过期时间，GMT格式日期（时间点）。</li><li><code>Last-Modified</code>: 响应头，资源最新修改时间。</li><li><code>if-Modified-Since</code>: 请求头，上次返回的<code>Last-Modified</code>发送给服务器，询问服务器在该日期后资源是否有更新，有更新就会发送新的资源回来。。</li><li><code>Etag</code>: 响应头，资源标识。像一个指纹，资源内容变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的。</li><li><code> if-None-Match</code>：请求头，上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来。</li></ul><p><code>ETag</code>的优先级比<code>Last-Modified</code>更高。</p><p>有了<code>Last-Modified</code>，为什么还要用<code>ETag</code>，主要出于下面几种情况考虑：</p><blockquote><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新<code>GET</code>；<br>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，<code>If-Modified-Since</code>能检查到的粒度是s级的，这种修改无法判断(或者说<code>UNIX</code>记录<code>MTIME</code>只能精确到秒)；<br>某些服务器不能精确的得到文件的最后修改时间。</p></blockquote><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><hr><p>强缓存通过<code>Expires</code>和<code>Cache-Control</code>两种响应头实现。</p><p>先判断缓存有效期，如果没过期，就继续用，过期就请求最新的文件，缓存起来，以此循环。</p><p><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/2020-06-21.png" alt="强缓存"></p><h2 id="协商缓存（弱缓存）"><a href="#协商缓存（弱缓存）" class="headerlink" title="协商缓存（弱缓存）"></a>协商缓存（弱缓存）</h2><hr><p>浏览器在协商性缓存情况下，都会无条件像服务器发起请求，判断自己的缓存是不是最新，如果是就接着用，不是就请求最新的文件，缓存起来用，以此循环。</p><p>协商缓存一般配合强缓存使用。当浏览器对某个资源的请求没有命中强缓存（是否过期），然后发一个请求到服务器，验证协商缓存是否命中（是否更新），如果协商缓存命中，请求响应返回的<code>http</code>状态为304并且会显示一个<code>Not Modified</code>的字符串。</p><p>协商缓存是利用的是<code>Last-Modified、If-Modified-Since</code>和<code>ETag、If-None-Match</code>这两对<code>Header</code>来管理的。<br><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/2020-06-22.png" alt="协商缓存"></p><p>强缓存与协商缓存的区别（命中为前提）:</p><table><thead><tr><th></th><th>获取资源形式</th><th>状态码</th><th>是否发送请求到服务器</th></tr></thead><tbody><tr><td>强缓存</td><td>从缓存取</td><td>200（from cache）</td><td>否，直接从缓存取</td></tr><tr><td>协商缓存</td><td>从缓存取</td><td>304（not modified）</td><td>是，通过服务器来验证缓存是否可用</td></tr></tbody></table><h2 id="http-缓存方案"><a href="#http-缓存方案" class="headerlink" title="http 缓存方案"></a>http 缓存方案</h2><hr><p>我们已经可以精确的对比服务器文件与本地缓存文件差异，但其实上面方案的演变都存在一个较大缺陷， <code>max-age</code>或<code>Expires</code>不过期，<strong>浏览器无法主动感知服务器文件变化</strong>。</p><p>解决方案：</p><h3 id="md5-hash-缓存"><a href="#md5-hash-缓存" class="headerlink" title="md5/hash 缓存"></a>md5/hash 缓存</h3><p>通过不缓存html，为静态文件添加<code>MD5</code>或者<code>hash</code>标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。</p><p>原理：</p><blockquote><p>前面说的http缓存方案，服务器与浏览器的文件修改时间对比，文件内容标识对比，前提基础都是建立在两者文件路径完全相同的情况下。<br>举个例子：未缓存html，module/js/a-hash1.js与module/js/a-hash2.js是两个完全不同的文件，假想浏览器第一次加载页面，请求并缓存了module/js/a-hash1.js，第二次加载，文件指向变成了module/js/a-hash2.js，浏览器会直接重新请求a-hash2.js，因为这就是两个完全不同的文件，哪里还有什么http缓存文件对比，通过这种做法，我们就可以从根本上解决过期时间没到浏览器无法主动请求服务器的问题。因此我们只需要在项目每次发布迭代将修改过的静态文件添加不同的MD5或hash标识就好啦。</p></blockquote><p>webpack提供了<code>webpack-md5-hash</code>插件，可以帮助开发者在项目发布时自动修改文件标识。</p><h3 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h3><p><code>cache-control</code>相关值介绍中，提到了例如<code>s-maxage</code>代理服务器。</p><h4 id="什么是-CDN"><a href="#什么是-CDN" class="headerlink" title="什么是 CDN ?"></a>什么是 CDN ?</h4><p>CDN 即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p>举个形象的例子：</p><blockquote><p>假设多年前我们所在的城市只有一个火车站，每次春运，整个城市的人都得去这个火车站买票，人流量以及购票的需求可想而知有多大，为了缓解这个问题，城市的不同区，都出现了火车票代售点，这样每个区的人都可以就近买票了，火车站总站的压力就这样大大减轻了。</p></blockquote><p>我们可以把每个区的售票点称之为 CDN 节点，也就是前面所说的代理服务器。简而言之，我们可以把 CDN 理解成浏览器与服务器之间的临时站点，它会替服务器处理一部分的浏览器请求，从而整理减轻总服务器的压力。</p><p>我们可以把 CDN 的价值归纳为：</p><ol><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。</li><li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载。</li></ol><h4 id="什么是-CDN-缓存"><a href="#什么是-CDN-缓存" class="headerlink" title="什么是 CDN 缓存?"></a>什么是 CDN 缓存?</h4><p>CDN 边缘节点缓存数据，当浏览器请求，CDN 将代替源站判断并处理此处请求。</p><p>请求一个CDN 缓存资源的过程：</p><blockquote><p>第一次请求：<br>浏览器：服务器老哥，我需要a.js。</p><p>服务器：（恼羞成怒）文件我给我小弟 CDN 了，以后你要这个找 CDN，别找我了。成功返回a.js给 CDN，CDN 进行缓存，同时 CDN 返回给浏览器，浏览器自己也进行了缓存(<strong>cache-control的值public</strong>就是用在这的)。</p><p>后续请求…<br>浏览器：服务器，我缓存时间到了，赶紧给我对比下文件，看看要不要重新返回给我。</p><p>CDN节点：打住打住，叫唤啥呢，我大哥比较忙，文件给我看看，请求被代理了。</p><p>大致又可以分两种情况：</p><p>情况1：CDN 节点自己缓存的文件未过期，于是返回了304给浏览器，打回了这次请求。</p><p>情况2：CDN 节点发现自己缓存的文件过期了，为了保险起见，自己发起请求给了服务器(源站)，成功拿回了最新数据，然后再交给与了浏览器。</p></blockquote><p>CDN 缓存的问题也跟前面的http缓存一样，CDN缓存时间不过期，浏览器始终被拦截，无法拿到最新的文件。</p><p>所以缺点也很明显：当网站更新时，如果CDN节点上数据没有及时更新，即便用户再浏览器使用Ctrl +F5的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。</p><p>但是我们回归 http 缓存问题本质，缓存本身针对于更新频率不高的静态文件，其次，CDN 缓存提供了分流以及访问加速等优势条件。</p><h2 id="用户的行为对缓存的影响"><a href="#用户的行为对缓存的影响" class="headerlink" title="用户的行为对缓存的影响"></a>用户的行为对缓存的影响</h2><hr><p><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/2020-06-24.png" alt="用户的行为对缓存的影响"></p><h2 id="相关博文："><a href="#相关博文：" class="headerlink" title="相关博文："></a>相关博文：</h2><hr><p><a href="https://www.cnblogs.com/echolun/articles/9419517.html">http缓存详解，http缓存推荐方案</a></p><p><a href="https://github.com/amandakelake/blog/issues/41">缓存（二）——浏览器缓存机制：强缓存、协商缓存</a></p><p><a href="https://blog.csdn.net/wangxin1982314/article/details/51050206">CDN缓存那些事</a></p><p><a href="https://www.zhihu.com/question/20790576">大公司里怎样开发和部署前端代码？</a></p>]]></content>
      
      
      <categories>
          
          <category> Web性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http 缓存 </tag>
            
            <tag> CDN 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存（一）</title>
      <link href="posts/de7b.html"/>
      <url>posts/de7b.html</url>
      
        <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><hr><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</p><h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><hr><p>通过复用已获取的资源，减少重新过去资源的延迟与网络阻塞，进而减少显示某个资源所用的时间，可以显著提高网站和应用程序的性能。</p><ul><li>缓存减少了冗余的数据传输，节省了你的网络费用。</li><li>缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。</li><li>缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。</li><li>缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。</li></ul><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><hr><p><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/2020-06-20.png" alt="缓存分类"></p><p>主要理解浏览器（客户端）方面的缓存。</p><h2 id="缓存实践"><a href="#缓存实践" class="headerlink" title="缓存实践"></a>缓存实践</h2><hr><p>具体情况具体分析</p><p>了解下大公司静态资源优化方案：</p><blockquote><ol><li>配置超长时间的本地缓存 —— 节省带宽，提高性能。</li><li>采用内容摘要作为缓存更新依据 —— 精确的缓存控制静态资源。</li><li>CDN部署 —— 优化网络请求。</li><li>更新资源发布路径实现非覆盖式发布 —— 平滑升级。</li></ol></blockquote><p>一、利用 <strong>http 缓存</strong> 机制：</p><blockquote><ol><li>对于某些不需要缓存的资源，可以使用<code>Cache-control: no-store</code> ，表示该资源不需要缓存。</li><li>对于频繁变动的资源（比如经常需要刷新的首页，资讯论坛新闻类），可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ol></blockquote><p>二、<strong>PWA(Service Worker)</strong></p><blockquote><p>静态资源文件通过 <code>Service Worker</code> 进行缓存控制和离线化加载。</p></blockquote><p>三、待续…..</p>]]></content>
      
      
      <categories>
          
          <category> Web性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http协议</title>
      <link href="posts/50cf.html"/>
      <url>posts/50cf.html</url>
      
        <content type="html"><![CDATA[<h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><hr><p>HTTP协议（超文本传输协议）是一个基于TCP/IP通信协议来传递数据的网络传输协议。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><hr><p>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</p><p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p><p><strong>HTTP请求响应过程：建立连接、发送请求信息、发送响应信息、关闭连接</strong>。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><hr><ul><li><code>HTTP</code> 是<strong>无连接</strong>。无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><code>HTTP</code> 是<strong>媒体独立</strong>。只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过<code>HTTP</code>发送。客户端以及服务器指定使用适合的<code>MIME type</code>内容类型。</li><li><code>HTTP</code>是<strong>无状态</strong>：<code>HTTP</code>协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><hr><p>一个<code>HTTP</code>事务由一条（从客户端发往服务器的）请求命令和一个（从服务器<br>发回客户端的）响应结果组成。这种通信是通过名为 <strong><code>HTTP</code>报文</strong>（HTTP message）<br>的格式化数据块进行的。</p><p><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/20201118091646.png" alt="包含请求及响应报文的 HTTP 事务"></p><h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><hr><p>HTTP 报文分为<strong>请求(Request)报文</strong>和<strong>响应(Response)报文</strong></p><p><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/20201118093848.png" alt="http://www.joes-hardware.com/tools.html 的 GET 事务实例"></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages">MDN关于HTTP报文的说明</a></p><h2 id="HTTP-报文响应头（请求头）"><a href="#HTTP-报文响应头（请求头）" class="headerlink" title="HTTP 报文响应头（请求头）"></a>HTTP 报文响应头（请求头）</h2><hr><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">MDN关于HTTP报文头信息的说明</a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><hr><p>常见的<code>HTTP</code>方法:</p><table><thead><tr><th>HTTP方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的资源信息，并返回实体主体。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报文头部信息。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和或已有资源的修改。</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的资源。</td></tr></tbody></table><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><hr><p><code>HTTP</code>状态码共分为5种类型：</p><table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>常见<code>HTTP</code>状态码：</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>301</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>304</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>400</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>403</td><td>服务器收到客户端的请求，但是拒绝执行此请求（无权限）</td></tr><tr><td>404</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>500</td><td>服务器内部错误，无法完成请求</td></tr></tbody></table><h2 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h2><hr><p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件。</p><p>Content-Type 标头告诉客户端实际返回的内容的内容类型。<br>如：<code>Content-Type: text/html; charset=utf-8</code></p><p>常见的媒体格式类型(<code>MIME type</code>):</p><p><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/20201118101931.png" alt="常见的媒体格式类型"></p><h2 id="在浏览器地址栏输入URL后"><a href="#在浏览器地址栏输入URL后" class="headerlink" title="在浏览器地址栏输入URL后?"></a>在浏览器地址栏输入URL后?</h2><hr><p><img src="https://raw.githubusercontent.com/liushunxing/cdn/master/blog/img/http/20201118102910.png" alt="在浏览器地址栏输入URL后"></p><ul><li>浏览器从 URL 中解析出服务器的主机名； </li><li>浏览器将服务器的主机名转换成服务器的 IP 地址； </li><li>浏览器将端口号（如果有的话）从 URL 中解析出来； </li><li>浏览器建立一条与 Web 服务器的 TCP 连接(三次握手)； </li><li>浏览器向服务器发送一条 HTTP 请求报文，请求服务器的资源文档 ； </li><li>服务器向浏览器回送一条 HTTP 响应报文，返回资源； </li><li>浏览器和服务器断开连接（四次挥手），浏览器开始解释处理HTML文档。</li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化</title>
      <link href="posts/b47b.html"/>
      <url>posts/b47b.html</url>
      
        <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>随着前端项目越来越复杂，js中全局变量污染和依赖混乱等问题严重。模块化越来越重要。</p><h2 id="一、早期"><a href="#一、早期" class="headerlink" title="一、早期"></a>一、早期</h2><ul><li>原始写法：一个函数一个模块。污染全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</li><li>对象写法：一个对象一个模块，模块成员作为对象属性。会暴露所有的模块成员。</li><li>立即执行函数：不暴露私有成员。</li><li>放大模式：一个模块很大，需要分成几个部分；一个模块需要继承另一个模块。<pre class="line-numbers language-JavaScript"><code class="language-JavaScript">var module1 = (function (mod)&#123;　　mod.m3 = function () &#123;　　　　//...　　&#125;;　　return mod;&#125;)(module1);  //module1模块添加了一个新方法m3()，然后返回新的module1模块。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。<pre class="line-numbers language-JavaScript"><code class="language-JavaScript">var module1 = ( function (mod)&#123;　　//...　　return mod;&#125;)(window.module1 || &#123;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>输入全局变量: 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。<pre class="line-numbers language-JavaScript"><code class="language-JavaScript">var module1 = (function ($, YAHOO) &#123;　　//...&#125;)(jQuery, YAHOO);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="二、CommonJS"><a href="#二、CommonJS" class="headerlink" title="二、CommonJS"></a>二、CommonJS</h2><p>CommonJS使用<code>exports</code>导出模块，<code>require</code>导入模块。<br><strong>同步</strong>加载，适合服务端，不适合浏览器。</p><h3 id="nodejs对CommonJS的实现"><a href="#nodejs对CommonJS的实现" class="headerlink" title="nodejs对CommonJS的实现"></a>nodejs对CommonJS的实现</h3><p>为了实现CommonJS规范，nodejs对模块做出了以下处理</p><ol><li>为了保证高效的执行，仅加载必要的模块。nodejs只有执行到<code>require</code>函数时才会加载并执行模块(同步)。</li><li>为了隐藏模块中的代码，nodejs执行模块时，会将模块中的所有代码放置到一个函数中执行，以保证不污染全局变量。<pre class="line-numbers language-JavaScript"><code class="language-JavaScript">(function()&#123;//模块中的代码&#125;)();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>为了保证顺利的导出模块内容，nodejs做了以下处理<ol><li>在模块开始执行前，初始化一个值<code>module.exports = &#123;&#125;</code></li><li><code>module.exports</code>即模块的导出值</li><li>为了方便开发者便捷的导出，nodejs在初始化完<code>module.exports</code>后，又声明了一个变量<code>exports = module.exports</code><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">(function(module)&#123;module.exports = &#123;&#125;;var exports = module.exports;//模块中的代码return module.exports;&#125;)()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li>为了避免反复加载同一个模块，nodejs默认开启了<strong>模块缓存</strong>，如果加载的模块已经被加载过了，则会自动使用之前的导出结果。</li></ol><hr><h2 id="三、AMD"><a href="#三、AMD" class="headerlink" title="三、AMD"></a>三、AMD</h2><p>全称是 Asynchronous Module Definition，即异步模块加载机制。<br>特点是可以实现<strong>异步加载模块</strong>，允许指定回调函数。等模块异步加载完成后即可调用回调函数。<br><strong>提前加载依赖的模块，依赖前置</strong>。<br>通过 <code>define</code> 来定义一个模块，然后使用 <code>require</code> 来加载一个模块。<br><code>require.js</code>实现了AMD规范。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">// define 既可以定义模块也可以导入模块define([依赖的模块列表], function(模块名称列表)&#123;    //模块内部的代码    return 导出的内容&#125;);require([导入模块列表], function(模块名称列表)&#123;    //回调函数代码&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="四、CMD"><a href="#四、CMD" class="headerlink" title="四、CMD"></a>四、CMD</h2><p>全称是 Common Module Definition，公共模块定义规范。<br><strong>异步加载，模块使用时才会加载执行，即依赖就近，按需加载依赖</strong>。<br>通过 <code>define</code> 来定义一个模块，然后使用 <code>require</code> 来加载一个模块。<br><code>sea.js</code>实现了CMD规范。</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">define(function(require, exports, module)&#123;    //通过 require 引入依赖。    //模块内部的代码    //可以通过 return 或 module.exports 导出内容&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="五、ES6模块化"><a href="#五、ES6模块化" class="headerlink" title="五、ES6模块化"></a>五、ES6模块化</h2><p>ES6模块化是一个官方的模块化标准。<br>目前，浏览器使用以下方式引入一个ES6模块文件:</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>入口文件<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="模块的基本导出和导入"><a href="#模块的基本导出和导入" class="headerlink" title="模块的基本导出和导入"></a>模块的基本导出和导入</h3><p>ES6中的模块导入导出分为两种：</p><ul><li>基本导入导出</li><li>默认导入导出</li></ul><hr><h4 id="基本导出"><a href="#基本导出" class="headerlink" title="基本导出"></a>基本导出</h4><p>类似于 <code>exports.xxx = xxxx </code><br>基本导出可以有多个，每个必须有名称。<br>基本导出的语法如下：<br><code>export 声明表达式</code><br>或<br><code>export &#123;具名符号&#125;</code></p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">import "./b.js" //这条导入语句，仅会运行模块，不适用它内部的任何导出export var a = 1; //导出a，值为1，类似于CommonJS中的exports.a = 1export function test() &#123; //导出test，值为一个函数，类似于CommonJS中的exports.test = function ()&#123;&#125;&#125;export class Person &#123;&#125;//导出Person，值为一个类export const name = "abc";var age = 18;var sex = 1;export &#123; age, sex &#125; //将age变量的名称作为导出的名称，age变量的值，作为导出的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于基本导出必须具有名称，所以要求导出内容必须跟上<strong>声明表达式</strong>或<strong>具名符号</strong>。</p><h4 id="基本导入"><a href="#基本导入" class="headerlink" title="基本导入"></a>基本导入</h4><p>由于使用的是<strong>依赖预加载</strong>，因此，导入任何其他模块，<strong>导入代码必须放置到所有代码之前</strong>。<br>对于基本导出，如果要进行导入，使用下面的代码<br><code>import &#123;导入的符号列表（和模块中的名称一致）&#125; from &quot;模块路径&quot; </code><br>注意以下细节：</p><ul><li><strong>导入时使用的符号是常量，不可修改</strong>。</li><li>导入时，可以通过关键字 <code>as</code> 对导入的符号进行重命名。</li><li>可以使用  <code>*</code> 号导入所有的基本导出(包括默认导出)，使用 <code>as</code> 重命名，形成一个对象。<pre class="line-numbers language-JavaScript"><code class="language-JavaScript">import "./a.js" //这条导入语句，仅会运行模块，不用它内部的任何导出import &#123;name, age&#125; from "./b.jsb"import * as c from "./c.js"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h3 id="默认导入导出"><a href="#默认导入导出" class="headerlink" title="默认导入导出"></a>默认导入导出</h3><h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><p>每个模块，除了允许有多个基本导出之外，还允许有一个默认导出（有且仅有一个）。<br>默认导出类似于CommonJS中的<code>module.exports</code>，由于只有一个，因此无需具名。<br>具体的语法：<br><code>export default 默认导出的数据</code><br>或<br><code>export &#123;默认导出的数据 as default&#125;</code></p><h4 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h4><p>导入一个模块的默认导出，使用下面的语法<br><code>import 接收变量名 from &quot;模块路径&quot;</code><br>类似于CommonJS中的 <code>var 接收变量名 = require(&quot;模块路径&quot;)</code><br>由于默认导入时变量名是自行定义的，因此没有别名一说。<br>如果希望同时导入某个模块的默认导出和基本导出，可以使用下面的语法：<br><code>import 接收默认导出的变量, &#123;接收基本导出的变量&#125; from &quot;模块路径&quot;</code></p><blockquote><p>如果使用 <code>*</code> 号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性 <code>default</code> 存在。</p></blockquote><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">//导出export var a = 1;export default &#123;    fn: function () &#123; &#125;,    name: "adsfaf"&#125;//导入import data from "./a.js" import data, &#123; a &#125; from "./a.js"import * as a from "./a.js"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模块化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CommonJS </tag>
            
            <tag> AMD </tag>
            
            <tag> CMD </tag>
            
            <tag> ES6模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful 设计规范</title>
      <link href="posts/196e.html"/>
      <url>posts/196e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Restful-API-具体设计规范"><a href="#Restful-API-具体设计规范" class="headerlink" title="Restful API 具体设计规范"></a>Restful API 具体设计规范</h1><p>Restful API 是一种互联网软件架构的设计规范、设计指南、设计风格、设计原则，如何设计一套合理、好用的 API。</p><h2 id="一、协议"><a href="#一、协议" class="headerlink" title="一、协议"></a>一、协议</h2><p>API与用户的通信协议，总是使用<strong>HTTPS协议</strong>。</p><h2 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h2><p>应该尽量将API部署在专用域名之下。</p><pre><code>https://api.example.com</code></pre><p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p><pre><code>https://example.org/api/</code></pre><h2 id="三、版本（Versioning）"><a href="#三、版本（Versioning）" class="headerlink" title="三、版本（Versioning）"></a>三、版本（Versioning）</h2><p>应该将API的版本号放入URL。</p><pre><code>https://api.example.com/v1/</code></pre><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。</p><h2 id="四、路径（Endpoint）"><a href="#四、路径（Endpoint）" class="headerlink" title="四、路径（Endpoint）"></a>四、路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在Restful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。</p><p>一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p><pre><code>https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees</code></pre><h2 id="五、HTTP-动词（方法）"><a href="#五、HTTP-动词（方法）" class="headerlink" title="五、HTTP 动词（方法）"></a>五、HTTP 动词（方法）</h2><p>对于资源的具体操作类型，HTTP 动词（方法）表示。<br>常用的 HTTP 动词（方法）有下面五个（括号里是对应的SQL命令）。</p><pre><code>GET（SELECT）：从服务器取出资源（一项或多项）。POST（CREATE）：在服务器新建一个资源。PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。DELETE（DELETE）：从服务器删除资源。</code></pre><p>还有两个不常用的HTTP动词。</p><pre><code>HEAD：获取资源的元数据。OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</code></pre><p>举个例子：</p><pre><code>GET  /zoos：列出所有动物园POST /zoos：新建一个动物园GET  /zoos/ID：获取某个指定动物园的信息PUT  /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET    /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</code></pre><h2 id="六、过滤信息（Filtering）"><a href="#六、过滤信息（Filtering）" class="headerlink" title="六、过滤信息（Filtering）"></a>六、过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p><p>常见的参数:</p><pre><code>?limit=10：指定返回数据的数量?offset=10：指定返回数据的开始位置(指定一个偏移量)?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件</code></pre><h2 id="七、状态码（Status-Codes）"><a href="#七、状态码（Status-Codes）" class="headerlink" title="七、状态码（Status Codes）"></a>七、状态码（Status Codes）</h2><p>务器向用户返回的状态码和提示信息</p><blockquote><p>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。<br>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。<br>202 Accepted - [<em>]：表示一个请求已经进入后台排队（异步任务）<br>204 NO CONTENT - [DELETE]：用户删除数据成功。<br>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。<br>401 Unauthorized - [</em>]：表示用户没有权限（令牌、用户名、密码错误）。<br>403 Forbidden - [<em>]： 表示用户得到授权（与401错误相对），但是访问是被禁止的。<br>404 NOT FOUND - [</em>]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。<br>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。<br>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。<br>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。<br>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</p></blockquote><h2 id="八、错误处理（Error-handling）"><a href="#八、错误处理（Error-handling）" class="headerlink" title="八、错误处理（Error handling）"></a>八、错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p><pre><code>&#123;    error: &quot;Invalid API key&quot;&#125;</code></pre><h2 id="九、返回结果"><a href="#九、返回结果" class="headerlink" title="九、返回结果"></a>九、返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><blockquote><ul><li>GET /collection：返回资源对象的列表（数组）</li><li>GET /collection/resource：返回单个资源对象</li><li>POST /collection：返回新生成的资源对象，以及有可能会加上是否成功</li><li>PUT /collection/resource：返回修改后的完整的资源对象，以及有可能会加上是否成功</li><li>PATCH /collection/resource：返回更新后的完整的资源对象，以及有可能会加上是否成功</li><li>DELETE /collection/resource：返回一个空文档，以及有可能会加上是否成功</li></ul></blockquote><h2 id="十、Hypermedia-API"><a href="#十、Hypermedia-API" class="headerlink" title="十、Hypermedia API"></a>十、Hypermedia API</h2><p>Restful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p><p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p><pre><code>&#123;&quot;link&quot;: &#123;  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,  &quot;title&quot;: &quot;List of zoos&quot;,  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;&#125;&#125;</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p><p>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p><pre><code>&#123;  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,  // ...&#125;</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p><pre><code>&#123;  &quot;message&quot;: &quot;Requires authentication&quot;,  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;&#125;</code></pre><p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><ul><li>API的身份认证应该使用OAuth 2.0框架。</li><li>服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</li></ul><p>原文 <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" title="RESTful API 设计指南">阮一峰</a></p>]]></content>
      
      
      <categories>
          
          <category> Restful API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Restful 设计规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful 架构</title>
      <link href="posts/57aa.html"/>
      <url>posts/57aa.html</url>
      
        <content type="html"><![CDATA[<h1 id="Restful-架构"><a href="#Restful-架构" class="headerlink" title="Restful 架构"></a>Restful 架构</h1><h2 id="一、起源"><a href="#一、起源" class="headerlink" title="一、起源"></a>一、起源</h2><p>REST 这个词，是 Roy Thomas Fielding (大牛) 在他2000年的博士论文中提出的。</p><h2 id="二、名称"><a href="#二、名称" class="headerlink" title="二、名称"></a>二、名称</h2><p>Fielding将他对互联网软件的架构原则，定名为 REST，即<strong>Representational State Transfer</strong>(表现层状态转化)。</p><p>如果一个架构符合REST原则，就称它为 Restful架构。</p><h2 id="三、资源（Resources）"><a href="#三、资源（Resources）" class="headerlink" title="三、资源（Resources）"></a>三、资源（Resources）</h2><p>REST中”表现层”其实指的是”资源”（Resources）的”表现层”。</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息</strong>。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。</p><blockquote><p>URI:统一资源标识符。是一个字符串。用来标识互联网资源的名称<br>URL:统一资源定位符。它是一种具体的URI</p></blockquote><p>可以用一个URI指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h2 id="四、表现层（Representation）"><a href="#四、表现层（Representation）" class="headerlink" title="四、表现层（Representation）"></a>四、表现层（Representation）</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。<strong>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）</strong>。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用<strong>Accept</strong>和<strong>Content-Type</strong>字段指定，这两个字段才是对”表现层”的描述。</p><h2 id="五、状态转化（State-Transfer）"><a href="#五、状态转化（State-Transfer）" class="headerlink" title="五、状态转化（State Transfer）"></a>五、状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，**如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”**。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：<strong>GET、POST、PUT、DELETE</strong>。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源</strong>。</p><h2 id="六、综述"><a href="#六、综述" class="headerlink" title="六、综述"></a>六、综述</h2><p>总结一下什么是Restful架构：</p><ul><li>每一个URI代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><h2 id="七、设计误区"><a href="#七、设计误区" class="headerlink" title="七、设计误区"></a>七、设计误区</h2><p><strong>最常见的一种设计错误，就是URI包含动词</strong>。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p><p>举例来说，某个URI是<code>/posts/show/1</code>，其中show是动词，这个URI就设计错了，正确的写法应该是<code>/posts/1</code>，然后用GET方法表示show。</p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：</p><pre><code>POST /accounts/1/transfer/500/to/2</code></pre><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p><pre><code>POST /transaction HTTP/1.1Host: 127.0.0.1from=1&amp;to=2&amp;amount=500.00</code></pre><p>原文 <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" title="理解RESTful架构">阮一峰</a></p>]]></content>
      
      
      <categories>
          
          <category> Restful API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Restful 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粘连布局</title>
      <link href="posts/8ccc.html"/>
      <url>posts/8ccc.html</url>
      
        <content type="html"><![CDATA[<h1 id="粘连布局"><a href="#粘连布局" class="headerlink" title="粘连布局"></a>粘连布局</h1><p>通俗的讲：如果有足够的内容将页面撑开，footer 可以被撑到网页下方去。但是，如果页面的内容很短，粘连 footer 仍然会出现在浏览器窗口的底部。</p><h2 id="footer高度固定"><a href="#footer高度固定" class="headerlink" title="footer高度固定"></a>footer高度固定</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>内容区域<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>footer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><pre class="line-numbers language-CSS"><code class="language-CSS">html, body &#123;    height: 100%;&#125;.main &#123;     min-height: 100%;     margin-bottom: -100px;     padding-bottom: 100px;     box-sizing: border-box;&#125; .footer &#123;     height: 100px;     background: yellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><pre class="line-numbers language-CSS"><code class="language-CSS">html, body &#123;    height: 100%;&#125;.main &#123;    min-height: 100%;    padding-bottom: 100px;    box-sizing: border-box;&#125;.footer &#123;    height: 100px;    margin-top: -100px;    background: yellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><pre class="line-numbers language-CSS"><code class="language-CSS">html,body &#123;    height: 100%;&#125;.main &#123;    min-height: calc(100vh - 100px);&#125; .footer &#123;    height: 100px;    background: yellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上只限于底部高度固定情况。flex 弹性盒子解决所有情况。</p><h2 id="flex-弹性盒子"><a href="#flex-弹性盒子" class="headerlink" title="flex 弹性盒子"></a>flex 弹性盒子</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>header<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>内容区域<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>footer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CSS"><code class="language-CSS">html &#123;    height: 100%;&#125;body &#123;    min-height: 100%;    display: flex;    flex-direction: column;&#125;.header&#123;    height: 100px;&#125;.main &#123;    flex: 1;&#125;.footer &#123;    background: yellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三栏布局</title>
      <link href="posts/2db5.html"/>
      <url>posts/2db5.html</url>
      
        <content type="html"><![CDATA[<h1 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h1><p>特征：中间列自适应宽度，旁边两侧固定宽度。</p><h2 id="一、浮动或绝对定位"><a href="#一、浮动或绝对定位" class="headerlink" title="一、浮动或绝对定位"></a>一、浮动或绝对定位</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CSS"><code class="language-CSS">/* 左右两边分别浮动或定位，中间部分设置margin: 0 右边宽度 0 左边宽度 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、flex-弹性盒子或者-grid-网格布局"><a href="#二、flex-弹性盒子或者-grid-网格布局" class="headerlink" title="二、flex 弹性盒子或者 grid 网格布局"></a>二、flex 弹性盒子或者 grid 网格布局</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>左边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>中间<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>右边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CSS"><code class="language-CSS">.wrapper &#123;    display: flex;&#125;.center &#123;    flex: 1;    height: 500px;    background: yellow;.left &#123;    width: 200px;    height: 500px;    background: red;&#125;.right &#123;    width: 300px;    height: 500px;    background: blue;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>和常规三栏布局相似，唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载。</p><blockquote><p>实现步骤:</p><ol><li>三个部分都设为左浮动，然后设置center的宽度为100%(实现中间列内容自适应)，此时，left和right部分会跳到下一行。</li><li>通过设置margin-left为负值让left和right部分回到与center部分同一行。</li><li>通过设置父容器的padding-left和padding-right，让左右两边留出间隙。</li><li>通过设置相对定位，让left和right部分移动到两边。</li></ol></blockquote><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>圣杯布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CSS"><code class="language-CSS">.wrapper &#123;    padding-left: 200px;    padding-right: 300px;&#125;.center &#123;    float: left;    width: 100%;    height: 500px;    background: yellow;&#125;.left &#123;    float: left;    width: 200px;    height: 400px;    background: red;    margin-left: -100%;    position: relative;    left: -200px;&#125;.right &#123;    float: left;    width: 300px;    height: 400px;    background: blue;    margin-left: -300px;    position: relative;    right: -300px;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行。<br>如果其中一列内容高度较高，其他两列的背景并不会自动填充。</p></blockquote><h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。</p><blockquote><p>实现步骤：</p><ol><li>三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；</li><li>通过设置margin-left为负值让left和right部分回到与center部分同一行；</li><li>center部分增加一个内层div，并设margin: 0 右边宽度 0 左边宽度。</li></ol></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>中间部分内容区域<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>左边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>右边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-CSS"><code class="language-CSS">.center &#123;    float: left;    width: 100%;    height: 500px;    background: yellow;.left &#123;    float: left;    width: 200px;    height: 500px;    background: red;    margin-left: -100%;.right &#123;    float: left;    width: 300px;    height: 500px;    background: blue;    margin-left: -300px;.inner &#123;    margin: 0 300px 0 200px; /* 300px 为右边的宽度，200px为左边的宽度 */&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="圣杯和双飞翼布局对比"><a href="#圣杯和双飞翼布局对比" class="headerlink" title="圣杯和双飞翼布局对比"></a>圣杯和双飞翼布局对比</h2><ol><li>两种布局方式都是把主列放在文档流最前，是主列优先加载。</li><li>实现上都是让三列浮动，然后通过负外边距形成三列布局。</li><li>不同在于如何处理中间主列的位置：</li><li>圣杯布局利用父容器的左、右内边距 + 两个边列相对定位。</li><li>双飞翼布局把主列嵌套在一个新的父级中利用主列的左、右外边距进行布局调整。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两栏布局</title>
      <link href="posts/bd25.html"/>
      <url>posts/bd25.html</url>
      
        <content type="html"><![CDATA[<h1 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h1><p>一栏固定宽度(或由内容撑开)，一栏自适应(假设左边固定，右边自适应)。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>左侧固定内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>右侧内容自适应<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、浮动-float"><a href="#一、浮动-float" class="headerlink" title="一、浮动 float"></a>一、浮动 float</h2><pre class="line-numbers language-CSS"><code class="language-CSS">/* 左侧float:left;右侧margin-left */.left &#123;    float: left;    width: 200px;    height: 200px;    background-color: skyblue;&#125;.right &#123;    height: 200px;    margin-left: 200px;    background-color: greenyellow;&#125;/* 左侧float:left;右侧overflow:hidden; */.right &#123;    height: 200px;    /* overflow:hidden触发BFC,不会重叠浮动元素 */    overflow:hidden;    background-color: greenyellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、绝对定位-position-absolute"><a href="#二、绝对定位-position-absolute" class="headerlink" title="二、绝对定位 position: absolute"></a>二、绝对定位 position: absolute</h2><pre class="line-numbers language-CSS"><code class="language-CSS">.left &#123;    position: absolute;    left: 0;    top: 0;    width: 200px;    height: 200px;    background-color: skyblue;&#125;/* .right 同方法1 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、弹性布局-display-flex"><a href="#三、弹性布局-display-flex" class="headerlink" title="三、弹性布局 display:flex;"></a>三、弹性布局 display:flex;</h2><pre class="line-numbers language-CSS"><code class="language-CSS">.wrapper&#123;    display: flex;&#125;.left &#123;    width: 200px;    height: 200px;    background-color: skyblue;&#125;.right &#123;    flex: 1;    height: 200px;    background-color: greenyellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、网格布局-display-grid"><a href="#四、网格布局-display-grid" class="headerlink" title="四、网格布局 display:grid"></a>四、网格布局 display:grid</h2><p>网格布局（Grid）是最强大的 CSS 布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p><pre class="line-numbers language-CSS"><code class="language-CSS">.wrapper&#123;    display:grid;    grid-template-columns:200px 1fr;&#125;.left &#123;    height: 200px;    background-color: skyblue;&#125;.right &#123;    height: 200px;    background-color: greenyellow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="posts/46d5.html"/>
      <url>posts/46d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre class="line-numbers language-txt"><code class="language-txt"># 这是一级标题## 这是二级标题### 这是三级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre class="line-numbers language-txt"><code class="language-txt">在文章开始地方输入[toc]，即可在对应位置插入目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre class="line-numbers language-txt"><code class="language-txt">斜体：左右用一个*号包起来加粗：左右用两个*号包起来斜体加粗：左右用三个*号包起来删除线：左右用两个~~号包起来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>斜体</em><br><strong>加粗</strong><br><strong><em>斜体加粗</em></strong><br><del>删除线</del></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;或三个&gt;&gt;&gt;，以此类推。</p><pre class="line-numbers language-txt"><code class="language-txt">>这是引用的内容>>这是引用的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>三个或者三个以上的 - 或者 * 。</p><pre class="line-numbers language-txt"><code class="language-txt">-------********<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><hr><hr><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre class="line-numbers language-txt"><code class="language-txt">![图片alt](图片地址 "图片title")图片alt是图片的名称，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://www.baidu.com/img/flexible/logo/pc/privacy.gif" alt="百度logo" title="百度"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre class="line-numbers language-txt"><code class="language-txt">[超链接名](超链接地址 "超链接title")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="http://baidu.com,/" title="百度">百度</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表用 - + * 任何一种都可以；有序列表用数字加点。</p><ul><li>无序列表</li></ul><ol><li>有序列表</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>下一级开头加两个空格</p><pre class="line-numbers language-txt"><code class="language-txt">- 一级  - 二级- 一级  1. 二级<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一级<ul><li>二级</li></ul></li><li>一级<ol><li>二级</li></ol></li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre class="line-numbers language-txt"><code class="language-txt">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>姓名</th><th align="center">技能</th><th>排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td>大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td>二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td>三弟</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-txt"><code class="language-txt">单行代码: `代码内容`代码块：代码之间分别用三个反引号包起来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>function</code></p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">function fn()&#123;  console.log(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="posts/f82e.html"/>
      <url>posts/f82e.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
